
# 简单的线程编排，多个线程可有序并发执行，支持连贯操作
## 前言
在进行分布式RPC调用时是比较耗时的，如果能让多个RPC并发运行可大大节约运行时间。但是由于业务逻辑复杂多变，多个RPC之间还可能存在依赖关系，例如某个RPC需要先执行，剩下的才能继续执行。
如果能控制RPC执行顺序，再结合多线程并发，那就既能保证业务逻辑，又能大大节省调用时间。

## 实现思路

**Caller类** 用于存储每个RPC的执行内容，回调以及异常处理，同时利用threadIndex字段记录该RPC操作的顺序;

**AsyncStack类** 是具体的业务逻辑，通过创建Caller类的实例保存RPC信息并将其存入callerList队列中，然后通过threadIndex来依次执行线程;

## 使用方法:
     new AsyncStack(()->线程1要执行的方法,(result)->线程1要执行的回调,()->线程1要执行的异常处理)
      .sync(() -> 线程2要执行的方法, (result) -> 线程2要执行的回调,()->线程2要执行的异常处理)
      .after(() -> 线程3要执行的方法, (result) -> 线程3要执行的回调,()->线程3要执行的异常处理)
      .after(() -> 线程4要执行的方法, (result) -> 线程4要执行的回调,()->线程4要执行的异常处理)
      .sync(() -> 线程5要执行的方法, (result) -> 线程5要执行的回调,()->线程5要执行的异常处理)
      .start();
如上:线程1和线程2将同步执行；线程1和2执行完后，线程3才能执行；线程3执行完后，线程4和线程5将同步执行。
